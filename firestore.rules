
/**
 * # Firestore Security Rules
 *
 * ## Core Philosophy
 * This ruleset enforces a strict user-ownership model. The primary goal is to ensure that users can only access and modify their own personal data, while public-facing data remains readable by all authenticated users. This approach prioritizes data privacy and integrity.
 *
 * ## Data Structure
 * The data is organized into two main categories:
 * 1. User-Private Data: All data specific to a user (profile, investments, transactions, etc.) is nested hierarchically under the `/users/{userId}` path. This structure naturally aligns with ownership-based security rules.
 * 2. Global Data: Collections like `/cars` contain data that is publicly readable but centrally managed.
 *
 * ## Key Security Decisions
 * - Default Deny: All operations are denied by default. Access is granted only through explicit `allow` statements.
 * - Strict Ownership: A user can only access documents within their own data tree (i.e., where the path contains their UID).
 * - No User Enumeration: Listing documents in the top-level `/users` collection is explicitly forbidden to prevent attackers from discovering user IDs. However, listing is allowed for a specific query on `referralCode`.
 * - Publicly Readable Cars: The `/cars` collection is readable by any signed-in user, but all write operations (create, update, delete) are restricted.
 * - Relational Integrity: On document creation, rules validate that ownership fields within the document (e.g., `userId`, `referrerId`) match the user ID in the document path, ensuring data consistency. These fields are immutable once set.
 *
 * ## Denormalization for Authorization
 * To create simpler and more performant rules, this ruleset relies on denormalization. Within user subcollections, an internal `userId` is validated against the path `userId` to ensure the document's data correctly reflects its location and ownership.
 *
 * ## Structural Segregation
 * The ruleset leverages separate collections for data with different access patterns. Private, user-owned data is segregated into `/users/{userId}/...` subcollections, while public-read data is placed in the top-level `/cars` collection. This separation makes list operations secure and efficient, as queries do not need to filter out private data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document.
     * Ensures that update/delete operations target a document that actually exists.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    function isAdmin() {
      return false; // Admin auth disabled
    }

    // --------------------------------
    // User Data Collections
    // --------------------------------

    /**
     * @description Manages user profile documents. Users can create their own profile,
     *   and can only read or write to their own document thereafter.
     * @path /users/{userId}
     * @allow (create) An authenticated user creating their own profile document. `request.auth.uid == userId`.
     * @allow (list) Allows querying for a user by their referral code.
     * @deny (get) A user trying to read another user's profile. `request.auth.uid != userId`.
     * @deny (list) Any user trying to list all documents in the `/users` collection without a specific filter.
     * @principle Enforces strict self-service and ownership for user profiles and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if true; // Public read for admin dashboard
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Manages a user's personal investment records.
     * @path /users/{userId}/investments/{investmentId}
     * @allow (create) An authenticated user creating an investment record for themselves. `request.auth.uid == userId`.
     * @deny (get) A user trying to read another user's investment. `request.auth.uid != userId`.
     * @principle Restricts access to a user's own data tree using path-based ownership.
     */
    match /users/{userId}/investments/{investmentId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages a user's personal referral records.
     * @path /users/{userId}/referrals/{referralId}
     * @allow (create) An authenticated user creating a referral record for themselves. `request.auth.uid == userId`.
     * @deny (get) A user trying to read another user's referral. `request.auth.uid != userId`.
     * @principle Restricts access to a user's own data tree using path-based ownership.
     */
    match /users/{userId}/referrals/{referralId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages a user's personal withdrawal requests.
     * @path /users/{userId}/withdrawals/{withdrawalId}
     * @allow (create) An authenticated user creating a withdrawal request for themselves. `request.auth.uid == userId`.
     * @deny (get) A user trying to read another user's withdrawal request. `request.auth.uid != userId`.
     * @principle Restricts access to a user's own data tree using path-based ownership.
     */
    match /users/{userId}/withdrawals/{withdrawalId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages a user's personal transaction history.
     * @path /users/{userId}/transactions/{transactionId}
     * @allow (create) An authenticated user creating a transaction record for themselves. `request.auth.uid == userId`.
     * @deny (get) A user trying to read another user's transaction. `request.auth.uid != userId`.
     * @principle Restricts access to a user's own data tree using path-based ownership.
     */
    match /users/{userId}/transactions/{transactionId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) || isOwner(request.resource.data.userId); // Allow for referral bonus
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    // --------------------------------
    // Global & Public Collections
    // --------------------------------

    /**
     * @description Manages car details available for investment. This data is public for any signed-in user to read.
     *   Writes are disallowed from the client.
     * @path /cars/{carId}
     * @allow (get) Any authenticated user reading a car's details.
     * @deny (create) Any user trying to add a new car.
     * @principle Implements a "Public Read with Admin-Only Writes" pattern for globally shared data.
     */
    match /cars/{carId} {
      allow get, list: if true; // Public read access
      allow create, update, delete: if true;
    }
  }
}
